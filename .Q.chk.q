chk:{
 / x: dir
 f:{`/:'x,'d@&(d:!x)like"[0-9]*"};
 /         ---subdirs matched---
 /      ----`parent`subdirs-----
 /  ----` sv ' (for each) ...--- (concatenation)
 d@:>.:'$last'`\:'d:$[`par.txt in!x; ,/f'-1!'`$0:`/:x,`par.txt; f x]
 {[e;u;d]
  / e:
  / u:
  / d:
   u[i] {.[x;(y;`);:;?[z;();0b;()]]}[d]' e i:&~u in!d
 } [d[(+u in/:t)?\:1b] (0#.)'u,'`; u:?,/t:!:'d]'d
}


.Q.chk


Восстанавливает отсутствующие таблицы в партициях HDB.
Для каждой таблицы в качестве опорной выбирает схему
из наиболее поздней партиции, где присутствует таблица.


= Подготовим вспомогательные функци


== Получить список всех партиций(file-symbol) в hdb
f:{
  / Get file-symbol list of all partitions in hdb(x)
  / x: hdb
  `/:'x,'d@&(d:!x)like"[0-9]*" }
  //vv
             d:!x               / Получить ключи объекта(hdb) - список папок(партиций hdb), сохранить в d
            (d:!x)like"[0-9]*"  / Партиции бывают типов (day/month/year/long) - поэтому папки должны содержать цифру
         d@&(d:!x)like"[0-9]*"  / Взять &(where) от бинарного списка и взять @(index) значения d от него
                                / Итак, здесь находятся партиции
      x,'d@&(d:!x)like"[0-9]*"  / Добавить "," к каждой '(each) партиции папку x в которой она находится
  `/:'x,'d@&(d:!x)like"[0-9]*"  / Склеить каждый такой список - превратить с помощью sv({x/:y}) в валидный путь
  //^^


== Создать таблицу в папке по ее схеме
f1:{
  / Create table(y) in directory(x) with schema(z)
  / x: directory
  / y: table
  / z: schema
  .[x;(y;`);:;?[z;();0b;()]] }
  //vv
              ?[z;();0b;()]   / функциональная форма select from z
  .[ ;     ;:;?[z;();0b;()]]  / replace-items-at-depth
  .[x;     ;:;?[z;();0b;()]]  / x file-symbol, ссылка на директорию
  .[x;(y;`);:;?[z;();0b;()]]  / (y;`) список ключей (поддиректорий), оканчивающийся
                              / либо символом, например (enlist y), тогда таблица запишется в файл
                              /   `:hdb/2020.01.01/`t1
                              / либо пустым символом`, как здесь, тогда таблица запишется в
                              /   `:hdb/2020.01.01/`t1/ как splayed - каждый столбец в свой файл
  //^^

=== Пример
  f1[`:hdb/2020.01.01; `t1; ([] c0:`float$())]
  hdb
  └── 2020.01.01
      └── t1
          ├── .d
          └── c0


== Создать отсутствующие таблицы в папке, зная их полный список и схемы
f2:{[e;u;d]
  / Create non-existent tables in directory(d) by their names(u) and schemas(e)
  / e: empty table list(schemas)
  / u: unique table list
  / d: dir(partition)
  u[i] f1[d]'e i:&~u in!d }
  //vv
                       !d     Получить ключи объекта, в данном случае подпапки (splayed-таблицы) партиции
                  ~u in!d     Получить бинарный список (длины u) наличия требуемых таблиц u
               i:&~u in!d     Взять where от него, сохранить в i: индексы таблиц в u, которые надо создать
             e i:&~u in!d     Индексы схем e, соответствующие таблицам u, которые надо создать
  u[i] f1[d]'e i:&~u in!d     С помощью adverbа each ' превратим проекцию(частично-примененную функцию) f1[d;;]
                              в функцию, которая применится ко всем [u[i];e[i]] - второй и третий аргументы f1
  //^^

=== Пример
  f1[`:hdb/2020.01.01; `t1; ([] c0:`float$())]
  f2[(([]c1:`short$()); ([]c2:`int$()); ([]c3:`long$())); `t1`t2`t3; `:hdb/2020.01.01]
  hdb             ->  hdb
  └── 2020.01.01      └── 2020.01.01
      └── t1              ├── t1
          ├── .d          │   ├── .d
          └── c0          │   └── c0
                          ├── t2
                          │   ├── .d
                          │   └── c2
                          └── t3
                              ├── .d
                              └── c3



= Обработаем случай Segmented tables, когда ссылки на сегменты с партицями хранятся в par.txt
  / x: `:hdb
  d:$[`par.txt in!x; ,/f'-1!'`$0:`/:x,`par.txt; f x] / dirs (partitions)
  //vv
  d:$[`par.txt in!x;                                 / Если среди ключей !x(`:hdb) находится par.txt
  d:$[`par.txt in!x;             `/:x,`par.txt       / Получить с помощью sv({x/:y}) валидный путь до par.txt
  d:$[`par.txt in!x;           0:`/:x,`par.txt       / Прочитать par.txt - получить из него строковый список сегментов
  d:$[`par.txt in!x;         `$0:`/:x,`par.txt       / Превратить строковый список партиций в символьный
  d:$[`par.txt in!x;     -1!'`$0:`/:x,`par.txt       / С помощью -1!(hsym) превратить каждый '(each) символ в file-сивмол
  d:$[`par.txt in!x;   f'-1!'`$0:`/:x,`par.txt       / С помощью f начитать из каждого '(each) сегмента список партиций
  d:$[`par.txt in!x; ,/f'-1!'`$0:`/:x,`par.txt       / Flatten, убрать уровень вложенности возникший из-за сегментов
  d:$[`par.txt in!x; ,/f'-1!'`$0:`/:x,`par.txt; f x] / Либо просто с помощью f начитать список партиций из hdb
  //^^


= Упорядочим список партиций d от самой новой до самой старой
  / d: dirs (partitions)
  d@:>.:'$last'`\:'d
  //vv
               `\:'d  / Превратить каждый путь до партиции в список symbol'ов
          last'`\:'d  / Взять последние символы (названия партиций)
         $last'`\:'d  / Превратить их в строки
      .:'$last'`\:'d  / Взять значение от каждой
     >.:'$last'`\:'d  / Упорядочить - упорядочивающие индексы, от самой новой партиции до строй
  d@:>.:'$last'`\:'d  / Amend in place, взять d от индексов и записать обратно в d
  //^^

= Получим уникальный список таблиц из ВСЕХ партиций и воссоздадим их во всех партициях

f2 [d[(+u in/:t)?\:1b] (0#.)'u,'`; u:?,/t:!:'d]'d

e:(([] c1:`short$());([] c2:`int$());([] c3:`long$()))
u:`t1`t2`t3
d:`:hdb/2020.01.01
